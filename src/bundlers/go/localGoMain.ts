export const template = `
/**
* GO
* This is an autogenerated code. This code should not be modified since the file can be overwritten
* if new genezio commands are executed.
 */
package main

import (
	"encoding/json"
	"net/http"
	"os"
    "io"

    {{#imports}}
    {{#named}}{{name}} {{/named}}"{{{path}}}"
    {{/imports}}
)

type Event struct {
	Body string \`json:"body"\`
}

type EventBody struct {
	Id      int           \`json:"id"\`
	Method  string        \`json:"method"\`
	Params  []interface{} \`json:"params"\`
	Jsonrpc string        \`json:"jsonrpc"\`
}

type ResponseBody struct {
	Id      int         \`json:"id"\`
	Result  interface{} \`json:"result"\`
	Jsonrpc string      \`json:"jsonrpc"\`
}

type Response struct {
	StatusCode string            \`json:"statusCode"\`
	Body       string            \`json:"body"\`
	Headers    map[string]string \`json:"headers"\`
}

func handleReuqest(w http.ResponseWriter, r *http.Request) {
	var event Event
	var body EventBody
	var responseBody ResponseBody

	err := json.NewDecoder(r.Body).Decode(&event)
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}
	eventBody := []byte(event.Body)
	// Decode the request body into struct and check for errors
	err = json.Unmarshal(eventBody, &body)
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}

    defer r.Body.Close()

	class := {{class.packageName}}.New()

	// Call the appropriate method
	switch body.Method {
    {{#jsonRpcMethods}}
    case "{{class.name}}.{{name}}":
        {{#parameters}}
        param{{index}} := body.Params[{{index}}].({{type}})
        {{/parameters}}
        {{^isVoid}}result, {{/isVoid}}err := class.{{name}}({{#parameters}}param{{index}}{{^last}}, {{/last}}{{/parameters}})
        if err != nil {
            http.Error(w, err.Error(), http.StatusInternalServerError)
            return
        }
        {{^isVoid}}
        responseBody.Result = result
        {{/isVoid}}
    {{/jsonRpcMethods}}
	// case "{{class.name}}.Post":
	// 	var user *models.User
	// 	jsonMap, err := json.Marshal(body.Params[0])
	// 	if err != nil {
	// 		http.Error(w, err.Error(), http.StatusInternalServerError)
	// 		return
	// 	}
	// 	err = json.Unmarshal(jsonMap, &user)
	// 	if err != nil {
	// 		http.Error(w, err.Error(), http.StatusInternalServerError)
	// 		return
	// 	}
	// 	class.Post(user)
	default:
		http.Error(w, "Method not found", http.StatusInternalServerError)
	}
	responseBody.Id = body.Id
	responseBody.Jsonrpc = body.Jsonrpc

    bodyString, err := json.Marshal(responseBody)
    if err != nil {
        http.Error(w, err.Error(), http.StatusInternalServerError)
        return
    }

	response := Response{
        StatusCode: "200",
		Body:       string(bodyString),
		Headers: map[string]string{
			"Content-Type": "application/json",
		},
	}

    // Encode the struct into JSON and check for errors
	responseByte, err := json.Marshal(response)
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}
	w.Header().Set("Content-Type", "application/json")
    w.WriteHeader(http.StatusOK)
	io.WriteString(w, string(responseByte))
}

func main() {
	port := os.Args[1]
	http.HandleFunc("/", handleReuqest)
	http.ListenAndServe(":"+port, nil)
}
`;
